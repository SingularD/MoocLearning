# 前端面试

### HTML

* 如何理解HTML的语义化标签
* 块级元素与内联元素区别，有哪些？

### CSS

* 清除浮动
* margin的纵向重叠
* margin为负值的时候，margin为百分比的时候
* 居中对齐与垂直对齐
* 圣杯布局和双飞翼布局
* Flex布局
* 响应式布局
* rem
* relative 和 absolute区别
* line-height的继承问题（百分比）

### JS

* BOM DOM
* 数据类型
* 原型与原型链
* 闭包
* 变量提升
* 异步 单线程

### 框架

* ReactJs
* VueJS
  * 数据双向绑定的原理：Vue中每个组件都有一个watcher，然后利用它来监听Object.defindProperty，当Object.defindProperty中的getter/setter方法调用的时候，watcher就会追踪他，当setter触发了，watcher就会检查自身是否有这个属性被修改，若有那么久通知render函数去重新渲染页面
* 虚拟DOM，Diff算法
  * 虚拟DOM：先将相比之前DOM树有改变的地方保存在一个js对象当中，然后在触发某个条件的时候在一起同时更新到DOM树上面，相比于传统的DOM不用每一次修改DOM后都去改变DOM树，节省了很大的性能。
  * 平层Diff `replace` 卸载原节点`text`更新文本 `props`更新属性 `reorder`移动，增加，删除节点，在数组或者枚举类型中，增加一个key属性，可以使得reorder过程效率更高，因为不用去使用暴力法来移动节点。
* 浏览器加载过程
  * 创建DOM树
  * 添加styleRules
  * 构建Render树
  * 布局layout
  * 绘制Painting

### HTTP相关

* 输入url后浏览器干了什么
  * 网络通信
    * 在浏览器中输入url
    * DNS解析域名，客户端会先检查本地是否有对应的IP地址，若有则返回，若没有则请求上级DNS服务器，直到找到或找到根节点
    * 应用层发送HTTP请求，HTTP包括请求报头和请求主题两个部分，请求头主要包含本次请求的信息，比如请求方法，目标url，遵循的协议，返回信息是否需要缓存等
      * HTTP
      * HTTPS
    * 传输层TCP传输报文
      * 传输层的TCP协议为传输报文提供可靠的字节流服务，为了方便传输，将大的数据切割成报文段为单位的数据包进行管理
      * 三次握手过程
    * 网络层IP协议查询MAC地址 ARP协议可以将IP地址解析成MAC地址（一个网络的IP地址可以更换，MAC地址为网卡id，即物理地址，一般不会改变）
    * 数据到达了数据链路层：找到了MAC地址后，将数据发送到数据链路层传输，此时客户端请求结束
    * 服务器接受数据：服务器在数据链路层拿到数据，在层层向上直到应用层，在底层拿到的数据通过TCP协议将数据白整合成完整的请求报文
    * 服务器响应请求：服务器这个时候接受到了HTTP请求，查找客户端请求的资源，并返回响应报文，响应报文包括一个很重要的属性状态码
      * 常见状态码：
    * 请求成功后，服务器就会返回响应的资源，进入页面渲染部分
  * 页面渲染
    * 生成DOM树
    * 添加StyleRules
    * 构建渲染树 render
    * 布局layout
    * 绘制 painting
* AJAX
* 前端缓存
  * 浏览器缓存 
    * 强缓存：不发送请求到服务器，直接从缓存之中读取资源，状态码为200
      * header字段
        * expires：设置过期时间，若请求时间在设置时间之内直接读取缓存，反正这请求服务器
        * cache-control：max-age=number设置缓存存在的时间，秒为单位
        * 若cache-control和expires同时存在cache-control优先级更高
    * 协商缓存：要发送请求，通过服务器来告知缓存是否可用，状态码304
      * Response Header Last-Modified，表示这个资源在服务器上的最后修改时间
      * Request Header If-Modified-Since 这就是上一次请求时返回的Last-Modified，这个时候服务器会判断在上次修改之后有没有变化，如果没有，则返回304 Not Modified 无资源内容，如果有则正常返回资源内容，若是304，服务器也不会去修改Last Modified。如果协商缓存没有命中，这在返回资源内容之后，修改Last modified,，重新执行上述循环
      * Etag/If-None-Match：这两个值是每个资源的唯一标识符，只要资源有改变就会改变，判断过程与Last Modified/If-Modified-Since类似。但是唯一不同的是服务器返回304的时候，服务器会重新生成Etag，哪怕这个值没有发生改变
      * Etag优先级高于Last-Modified
  * 本地缓存
    * `LocalStorage`本地缓存 大小5M
    * `sessionStorage`
    * `cookie`
    * HTML5新属性 `applicationCache` => PWA
* cookie session token的区别
  * cookie 由服务器生成，永久储存在本地浏览器，数量有限
  * session 由服务器生成，也临时保存在服务器上面，但是随着用户关闭浏览器，它也销毁
  * token 用于验证的令牌，服务器只做验证，大大减轻了服务器的负载
* 负载均衡
  * DNS轮询：最简单的负载均衡，以域名作为访问入口，通过配置多条DNS，可使请求分配到不同的服务器，容易将服务器的真是地址暴露给用户，所以不安全
  * CDN：通过分发机制将相同内容同步到大量的缓存节点，在DNS服务器上扩展，找到离用户最近的缓存节点作为服务提供节点
  * IP负载均衡：基于特定的TCP/IP技术实现负载均衡
* Apache与Nginx对比
  * Apache 性能不如Nginx，但是超稳定，处理动态请求效果更好
  * Nginx 性能好，但是不如Apache稳定，处理静态文件和反向效果更好，负载均衡服务器

### 网络安全

* XSS 跨站脚本攻击 不需要登录
  * 原理，通过合法操作在你的url或者输入框在你的页面中注入脚本
  * 攻击方式 
    * 反射型 通过在你的url中注入XSS代码，XSS代码随着响应返回给浏览器，最后浏览器执行该段恶意代码
    * 储存型 与反射型的区别在于这段恶意代码不会返回给浏览器，而是储存在服务器中
  * 防御方案：前端对用户的输入进行校验，先对js转义后在存入数据库或者转义页面上的信息，防止页面js的执行。
* CSRF 跨站请求伪造 需要用户登录
  * 你在访问A（正常网站）的时候，会给你生成一个cookie，如果你没有登录，网站B（危险网站）会诱导你登录A网站
  * 在你没有退出A网站的时候访问B网站，他就会拿到你的cookie
  * 防护措施每次发起请求的时候带上token

### 数据结构

* 排序算法

