# ES6 #

### let 与 const 

#### let

块级作用域： 通俗地讲就是用” {} “包裹起来的区域

let声明的变量只能在当前的块级作用域中使用，不能重复声明

不存在变量提升

存在暂存死区



#### const

不存在变量提升

声明的时候必须赋值，一旦声明就不能修改，引用类型除外，需要使用到引用类型冻结

不能重复声明

只在当前作用域内有效



### 结构赋值

#### 数组与对象的解构赋值

数组：(解构赋值时与数组元素顺序有关)

```js
let [a, b, c] = [1, 2, 3] //可对abc分别赋值
```

```Js
let [a, ...b] = [1, 2, 3] // a=1,b=[2,3]
let [ , , c] = [1, 2, 3] // c = 3
let [a, [b, c], d] = [1, [2, 3], 4] // a=1 ... d=4
```

对象： （解构赋值时与属性方法顺序无关，只与属性名和方法名有关）

```js
const person = {
    name: 'li',
    age: 20,
    hobby: '学习'
}
const { age } = person // 20

```

```js
const person = {
    name: 'li',
    age: 20,
    hobby: [
        '学习',
        '游戏',
        '吃饭'
    ],
    son: {
        name: 'xiaoli',
        age: 10
    }
}
const { name, age, hobby:[a,b,c],son:{name: sonName} } = person
// name='li' age:20 b="学习" sonName="xiaoli"
```

在对象的解构赋值的时候，同名的加一个冒号写上一个新的变量名即可给其赋值，就像上面的sonName一样，在对象或者数组在进行解构赋值的前面要加上数组或者对象名和冒号，在他们之后再进行解构赋值，最有一点在解构赋值的时候如果解构的元素未赋值，那么是可以给一个默认值的：

```js
const student = {
    name: "li",
    age: 10
}
const { name, hobby="学习" } = student // name="li" hobby="学习"
```





#### 字符串模板

在ES6之前我们处理字符串模板的方式是

```js
var person = {
    name: "lisongwei",
    age:20
}
var div = document.createElement('div');
div.innerHtml = '<p>姓名是：' + person.name + '</p>' +
    '<p>年龄是：'+ person.age +'</p>'
document.body.appendChild(div)
```

现在使用ES6新特性来构造字符串模板

```Js
const person = {
    name: "lisongwei",
    age:20
}
const div = document.createElement('div');
div.innerHtml = ` <p>姓名是：${person.name}</p><p>年龄是：${person.age}</p> `
document.body.appendChild(div)
```

可以达到相同的效果在`${}`中，可以添加js的函数表达式



#### 扩展运算符 `...`

扩展运算符`…`在字符串，数组，对象之中都有很多的运算，起主要作用是`拆分`比如

```js
let str = 'abcdefg';
let [...str1] = str; 
// let str1 = [...str] 与上面的代码等价
console.log(str1) // ["a", "b", "c", "d", "e", "f", "g"]
```

 对于一个数组

```js
let arr = ['li', 'song', 'wei'];
let arr1 = ['shuai', 'ge'];
let Arr = [...arr, ...arr1];// 相当于拆分了arr和arr1,同时组合成新数组
console.log(Arr) // ["li", "song", "wei", "shuai", "ge"]

// 同时利用该特性 ：Array.push(el) 等价于 [...Array, el] 向数组最后一位添加元素
// 向数组首位添加元素：[el, ...Array]
```

对于对象

```js
const obj1 = {
    name: 'lisongwei',
    age: 22
}
const obj2 ={
    hobby: [
        '学习',
        '游戏'
    ]
}
let Obj = {...obj1, ...obj2} // 将两个对象合并为一个

```

在函数参数之中：

```js
let [a,b,c,d] = [1,2,3,4]
function add (a, b, c, d) {
    // ...
    // ...
    // ...
}
//当参数个数太多或者不清楚时候可以使用...args
function (a, ...args) {
    // ...
    // ...
    // ...
}
//...agrs是一个数组，包含了a之后所有的参数
```



#### Promise

Promise用于触发回调，相对于传统的回调写法，优化了很多

```Js
const display = (args) => {
    return new Promise( ( resolve, reject ) => {
        if ( args ) {
            resolve(params1)
        }else {
            reject(params2)
        }
    } )
}

const success = (val) => {
    console.log(val)
    // ...
    // ...
    // ...
} // 成功执行的回调函数

const fail = (err) => {
    console.log(err)
    // ...
    // ...
    // ...
} // 失败时候执行的回调

display(true).then(success) //成功执行success函数
// display(false).then(fail) 失败执行fail函数
// 在Promise中resolve函数就是回调函数，也就是放在.then()之中的函数,只用在其中加入函数
// 名即可不需要加括号，在声明的时候reslove已经规定好了参数

Promise.all([p1, p2, p3]).then(fn)
// .all方法是指p1,p2,p3都成功的时候三个promise同时回调.then()中的函数，返回值也是一个
// 数组 
promise.race([p1,p2,p3]).then(fn) //.all相当于且，.race相当于或，有一个成功的时候
// 就全部执行回调函数

```



#### class

对于js中的类，实际相当于一个语法糖，那么声明类的主要方式是

```Js
class object {
    constructor() {   
        // ...
        // ...
        // ...
        // constructor是类的构造函数，是在类实例的时候运行的函数
        // 构造函数中传入的函数也就是实例对象的时候传入的参数
    }
    // ...
    // 方法 形式 functionName () {}
}
```

类的表达式和get/set方法

我们在实例一个类的时候：

```js
const person = new Person();
const person = class Person {
    // ...
    // ...
    // ...
    //在这里调用Person.属性或者Person.方法相当于 person.属性,person.方法
	// 但是当你实例对象不为person的时候 person.属性,person.方法失效了，所以这个
    // 时候最好是使用类的表达式，直接使用Person.属性或者Person.方法
}
```



```Js
// get set方法

class Person {
    constructor() {
        this.name = '';
    }
    get name() {
        return this.name;
    }
    set name(value) {
        this.name = value
    }
}
const person = new Person();
console.log(person.name) // 这个时候浏览器或者node一定会报错，错误为堆栈溢出
// 我们在调用person.name 的时候实际当用了Person类里面的get方法，而且调用的是
// get name() {} 这样就会一直递归调用，所以会爆栈，所以我们必须修改name属性名
// 我们将name属性改为 _name ，如下

class Person {
    constructor() {
        this._name = '';
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value
    }
}
const person = new Person();
// 这个时候就不会出现上述错误
// 以此为例 get就相当于 person.name
// set相当于 perosn.name = value
// 不需要使用person.getName或者person.setName这种方法
```



