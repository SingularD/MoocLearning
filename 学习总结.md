# ES6 #

### let 与 const 

#### let

块级作用域： 通俗地讲就是用” {} “包裹起来的区域

let声明的变量只能在当前的块级作用域中使用，不能重复声明

不存在变量提升

存在暂存死区



#### const

不存在变量提升

声明的时候必须赋值，一旦声明就不能修改，引用类型除外，需要使用到引用类型冻结

不能重复声明

只在当前作用域内有效



### 结构赋值

#### 数组与对象的解构赋值

数组：(解构赋值时与数组元素顺序有关)

```js
let [a, b, c] = [1, 2, 3] //可对abc分别赋值
```

```Js
let [a, ...b] = [1, 2, 3] // a=1,b=[2,3]
let [ , , c] = [1, 2, 3] // c = 3
let [a, [b, c], d] = [1, [2, 3], 4] // a=1 ... d=4
```

对象： （解构赋值时与属性方法顺序无关，只与属性名和方法名有关）

```js
const person = {
    name: 'li',
    age: 20,
    hobby: '学习'
}
const { age } = person // 20

```

```js
const person = {
    name: 'li',
    age: 20,
    hobby: [
        '学习',
        '游戏',
        '吃饭'
    ],
    son: {
        name: 'xiaoli',
        age: 10
    }
}
const { name, age, hobby:[a,b,c],son:{name: sonName} } = person
// name='li' age:20 b="学习" sonName="xiaoli"
```

在对象的解构赋值的时候，同名的加一个冒号写上一个新的变量名即可给其赋值，就像上面的sonName一样，在对象或者数组在进行解构赋值的前面要加上数组或者对象名和冒号，在他们之后再进行解构赋值，最有一点在解构赋值的时候如果解构的元素未赋值，那么是可以给一个默认值的：

```js
const student = {
    name: "li",
    age: 10
}
const { name, hobby="学习" } = student // name="li" hobby="学习"
```





#### 字符串模板

在ES6之前我们处理字符串模板的方式是

```js
var person = {
    name: "lisongwei",
    age:20
}
var div = document.createElement('div');
div.innerHtml = '<p>姓名是：' + person.name + '</p>' +
    '<p>年龄是：'+ person.age +'</p>'
document.body.appendChild(div)
```

现在使用ES6新特性来构造字符串模板

```Js
const person = {
    name: "lisongwei",
    age:20
}
const div = document.createElement('div');
div.innerHtml = ` <p>姓名是：${person.name}</p><p>年龄是：${person.age}</p> `
document.body.appendChild(div)
```

可以达到相同的效果在`${}`中，可以添加js的函数表达式